---
title: ffmpeg
date: 2022-05-29 18:14:50
tags:
  - ffmpeg
categories:
  - 工具
---
ffmpeg

<!-- more -->

## 基础

- ffmpeg读取任意个input（使用-i指定），写到任意个输出（通过plain output url指定）
- 每个输出或者输出可以包含任意数量的不同类型的流(stream)，streams种类有`video/audio/subtitle/attachment/data`
- stream的类型和数量受容器格式(container format)影响，从哪些input选取哪些流，输出到哪些output的过程（**stream selection**）既可以是自动的也可以通过`-map`指定。
- **options对下一个文件起作用**，可以重复相同的选项
- 引用input或者stream，可以使用从0开始的索引。比如第一个输入是`0`，`2:3` 表示第3个文件的第4个流

一些简单的例子

Convert an input media file to a different format, by re-encoding media streams:
```
ffmpeg -i input.avi output.mp4
```
Set the video bitrate of the output file to 64 kbit/s:
```
ffmpeg -i input.avi -b:v 64k -bufsize 64k output.mp4
```
Force the frame rate of the output file to 24 fps:
```
ffmpeg -i input.avi -r 24 output.mp4
```
Force the frame rate of the input file (valid for raw formats only) to 1 fps and the frame rate of the output file to 24 fps:
```
ffmpeg -r 1 -i input.m2v -r 24 output.mp4
```
### ffmpeg流程

- **decode -> filter -> encode**
- 使用copy选项时，可以跳过decode。Encoded packets are then passed to the decoder (unless streamcopy is selected for the stream, see further for a description).
  ```
   _______              ______________
  |       |            |              |
  | input |  demuxer   | encoded data |   decoder
  | file  | ---------> | packets      | -----+
  |_______|            |______________|      |
                                             v
                                         _________
                                        |         |
                                        | decoded |
                                        | frames  |
                                        |_________|
   ________             ______________       |
  |        |           |              |      |
  | output | <-------- | encoded data | <----+
  | file   |   muxer   | packets      |   encoder
  |________|           |______________|
  ```

### filter

#### simple filter
- 一个输入，一个输出，类型相同
- 对每个流使用-filter选项。-vf, -af是video和audio的别名
```
_________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
           \   __________   /
simple     _\||          | /  encoder
filtergraph   | filtered |/
              | frames   |
              |__________|

```
 
#### Complex filter
Complex filter graphs are those which cannot be described as simply a linear processing chain applied to one stream.
- 多个输入或输出
- 使用`-filter_complex`
- 默认是全局的选项

例子

overlay：将一个视频叠加到另一个视频上

Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs.  “Filtergraph syntax” section of the ffmpeg-filters manual.
  
Input link labels must refer to input streams using the `[file_index:stream_specifier]` syntax (i.e. the same as -map uses). If stream_specifier matches multiple streams, the first one will be used. An unlabeled input will be connected to the first unused input stream of the matching type.

Output link labels are referred to with -map. Unlabeled outputs are added to the first output file.

```
ffmpeg -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map
        '[out]' out.mkv
```

### stream selection

#### 自动选择
- 根据output文件的类型，决定是否包含video/audio/subtitles等各种类型的流
- 流选择的具体规则
  - for video, it is the stream with the highest resolution,
  - for audio, it is the stream with the most channels,
  - for subtitles, it is the first subtitle stream found but there’s a caveat. The output format’s default subtitle encoder can be either text-based or image-based, and only a subtitle stream of the same type will be chosen.
#### map选项

`-map [-]input_file_id[:stream_specifier][?][,sync_file_id[:stream_specifier]] | [linklabel] (*output*)`

Designate one or more input streams as a source for the output file. Each input stream is identified by the input file index input_file_id and the input stream index input_stream_id within the input file. Both indices start at 0. If specified, sync_file_id:stream_specifier sets which input stream is used as a presentation sync reference.

例子

For example, if you have two audio streams in the first input file, these streams are identified by "0:0" and "0:1". You can use `-map` to select which streams to place in an output file.

For example:
```
ffmpeg -i INPUT -map 0:1 out.wav
```
will map the input stream in INPUT identified by "0:1" to the (single) output stream in out.wav.

For example, to select the stream with index 2 from input file a.mov (specified by the identifier "0:2"), and stream with index 6 from input b.mov (specified by the identifier "1:6"), and copy them to the output file out.mov:
```
ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov
```

To select all video and the third audio stream from an input file:
```
ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT
```

To map all the streams except the second audio, use negative mappings
```
ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT
```

To map the video and audio streams from the first input, and using the trailing `?`, ignore the audio mapping if no audio streams exist in the first input:
```
ffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT
```

To pick the English audio stream:
```
ffmpeg -i INPUT -map 0:m:language:eng OUTPUT
```

Note that using this option disables the default mappings for this output file.

### stream handling

Stream handling is independent of stream selection, with an exception for subtitles described below. Stream handling is set via the `-codec` option addressed to streams within a specific _output_ file. In particular, codec options are applied by ffmpeg after the stream selection process and thus do not influence the latter. If no `-codec` option is specified for a stream type, ffmpeg will select the default encoder registered by the output file muxer.
- 在stream selection之后进行
- 使用-codec指定对output中流的处理方式
- 如果没有指定-codec，则按照output文件格式选择默认的encoder

### Options

*注意：ffmpeg很多选项，其关于input/output的位置的不同，会产生完全不同的效果*
#### stream specifier

对于一些针对某个流的选项（如-codec, -bitrate），使用stream specifier来指定针对哪个流。Some options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) a given option belongs to.
如：
- -codec: a:1 ac3，指定第**2**个**audio**流的编码
- -codec:v copy指定复制video流（-codec or -codec:指定复制所有流）

#### main options

- ` -c[:stream_specifier] codec (input/output,per-stream)`
  **Select an encoder (when used before an output file) or a decoder (when used before an input file)**  for one or more streams. codec is the name of a decoder/encoder or a special value copy (output only) to indicate that the stream is not to be re-encoded.
  
  ```
  ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT
  ```
  encodes all video streams with libx264 and copies all audio streams.
  
  作用顺序为后者优先
  ```
  ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT
  ```
  will copy all the streams except the second video, which will be encoded with libx264, and the 138th audio, which will be encoded with libvorbis.

- `-t duration (*input/output*)`
  When used as an input option (before `-i`), limit the duration of data read from the input file.
  When used as an output option (before an output url), stop writing the output after its duration reaches duration.

- `-ss position (*input/output*)`
    When used as an input option (before `-i`), seeks in this input file to position. 
    - Note that in most formats it is not possible to seek exactly, so `ffmpeg` will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded
    -  When doing stream copy or when -noaccurate_seek is used, it will be preserved.
    When used as an output option (before an output url), decodes but discards input until the timestamps reach position.

- `-to position (*input/output*)`
  Stop writing the output or reading the input at position.

- `-filter[:stream_specifier] filtergraph (*output,per-stream*)`
  Create the filtergraph specified by filtergraph and use it to filter the stream.
  
  filtergraph is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label `in`, and the output to the label `out`. See the ffmpeg-filters manual for more information about the filtergraph syntax.

- Video相关
  - `-vn (input/output)`
    As an input option, **blocks all video streams of a file from being filtered or being automatically selected or mapped for any output.** See `-discard` option to disable streams individually.
    As an output option, disables video recording i.e. automatic selection or mapping of any video stream. For full manual control see the `-map` option.
  - `-vcodec codec (output)`
  - `-vf filtergraph (output)`
    Create the filtergraph specified by filtergraph and use it to filter the stream.
## quick start

参考：[FFmpeg 视频处理入门教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2020/01/ffmpeg.html)
### 命令格式

```
$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]
```

如下面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。

```
$ ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件
```

### 常用参数

```
-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
```

### 查看支持的编码器

```
~ ffmpeg.exe -encoders |grep av1
 V..... libaom-av1           libaom AV1 (codec av1)
 V....D librav1e             librav1e AV1 (codec av1)
 V..... libsvtav1            SVT-AV1(Scalable Video Technology for AV1) encoder (codec av1)
 
~ ffmpeg.exe -encoders |grep HEVC
 V..... libx265              libx265 H.265 / HEVC (codec hevc)
 V....D hevc_amf             AMD AMF HEVC encoder (codec hevc)
 V....D hevc_mf              HEVC via MediaFoundation (codec hevc)

~ ffmpeg.exe -encoders |grep h264
V..... libx264              libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264)
 V..... libx264rgb           libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264)
 V..... libopenh264          OpenH264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264)
 V....D h264_amf             AMD AMF H.264 Encoder (codec h264)
 V....D h264_mf              H264 via MediaFoundation (codec h264)
 V....D h264_nvenc           NVIDIA NVENC H.264 encoder (codec h264)
 V..... h264_qsv             H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (Intel Quick Sync Video acceleration) (codec h264)
 V..... nvenc                NVIDIA NVENC H.264 encoder (codec h264)
 V..... nvenc_h264           NVIDIA NVENC H.264 encoder (codec h264)
```

## 心得(坑)

- 流复制不用转码是很好，但是会导致各种问题。比如seek不精确、seek后视频和音频长度相差几百ms。因此剪辑视频最稳妥起见还是重新转码一下
- 转码时crf一定要选好，默认的码率是很低的
h265
  - crf 26: 11mbps（B站转成h264就剩10mb了，但实际最高可达18mb）
  - crf 20: 22281kb
  - crf 16: 34894kb

## 常用命令

### 查看文件元信息

```
ffmpeg -i input.mp4 -hide_banner
```

### 提取音频

输出文件可以选择不同容器格式，根据音频编码选择。（如m4a, mp3，也可以直接用mkv存储）
```
$ ffmpeg -i input.mp4 -vn -c:a copy output.aac
```
### 截图

```
$ ffmpeg -i input.mp4 -ss 00:01:24 -t 00:00:01 output_%3d.jpg
```

`-vframes 1`指定只截取一帧，`-q:v 2`表示输出的图片质量，一般是1到5之间（1 为质量最高）。

```
$ ffmpeg -ss 01:23:45 -i input -vframes 1 -q:v 2 output.jpg
```

## 参考资料

[FFmpeg Formats Documentation](https://ffmpeg.org/ffmpeg-formats.html)
-fflags flags是另外的选项
- ‘genpts’：Generate missing PTS if DTS is present.

[video - Does PTS have to start at 0? - Stack Overflow](https://stackoverflow.com/questions/51085133/does-pts-have-to-start-at-0)
- 想让start_pts包含实际时间信息

[video - ffmpeg setpts apply uniform offset without re-encoding - Stack Overflow](https://stackoverflow.com/questions/53388471/ffmpeg-setpts-apply-uniform-offset-without-re-encoding)
- 两个流，知道结尾，因此可以同步
- 使用setpts filter可以做到，但是想要避免转码

## 截取Seeking位置

**一定要读**：[Seeking – FFmpeg](https://trac.ffmpeg.org/wiki/Seeking)


**关键帧（Keyframes）**：在视频编码中，关键帧是视频序列中的特殊帧，**它们是独立的、不依赖于其他帧的帧**。关键帧包含完整的图像信息，而其他帧（如P帧和B帧）则利用关键帧和/或其他帧的信息进行压缩。
关键帧是视频中的重要参考点，它们通常出现在视频场景变化或运动发生的地方。由于关键帧是独立的，视频播放器或解码器可以在任何关键帧处开始解码，而不需要依赖之前的帧。这有助于快速定位和随机访问视频。

**PTS（Presentation Timestamp）**：
PTS是一个时间戳，表示视频或音频帧在播放时应该呈现的时间。PTS用于确定帧何时应该在播放时间轴上显示或播放。

**GOP（Group of Pictures）**：GOP是视频序列中的一组帧，它包含一个关键帧（I帧）和一些后续帧，包括预测帧（P帧）和双向预测帧（B帧）。GOP的结构有助于视频压缩和解码。
典型的GOP结构可能是"IBBPBBPBBPBB"，其中"I"是关键帧，"B"是双向预测帧，"P"是预测帧。关键帧始终是GOP的第一个帧。

**关键帧和GOP的关系**：
关键帧是GOP的起点，它定义了一个新的编码组，其后跟随一系列依赖于它的预测帧和双向预测帧。整个GOP的结构有助于在视频编码中实现高压缩比，因为预测帧和双向预测帧可以利用关键帧的信息进行差异编码，而不必携带完整的图像信息。
在视频流中，关键帧的选择和GOP的设置对于视频的质量、压缩效率和快速定位能力都具有重要影响。不同的应用和使用场景可能需要不同的关键帧间隔和GOP结构来平衡压缩效率和解码性能。

### 查看关键帧方法

```
ffprobe -select_streams v -show_frames -show_entries frame=pict_type,pkt_pts_time bbb_sunflower_1080p_30fps_normal.mp4 > log
```
### input seeking

-ss  position (_input/output_)

When used as an input option (before `-i`), seeks in this input file to position. Note that in most formats it is not possible to seek exactly, so `ffmpeg` will seek to the closest seek point **before** position.

- 简单理解为seek到I帧。
- 转码时：When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded
- copy时：When doing stream copy or when -noaccurate_seek is used, it will be preserved.
  - 由于不能编解码，所以实际seek位置必须对应I帧，因此seek位置实际在pos最前的一个I帧，然后将ts置为0？

#### 实验

```
ffmpeg -i bbb_sunflower_1080p_30fps_normal.mkv -t 10 ref/ref_%04d.png

f421d45d1b8b491dc36a564c01246ef8  i_ss_2-noacc.png
468a10a80c838526709d4d35abe7af3a  i_ss_2.png

(base) fyyuan@icarus4 ➜  test cat ref/log2|grep f421d45d1b8b491dc36a564c01246ef8
f421d45d1b8b491dc36a564c01246ef8  ref_0061.png
(base) fyyuan@icarus4 ➜  test cat ref/log2|grep 468a10a80c838526709d4d35abe7af3a
468a10a80c838526709d4d35abe7af3a  ref_0059.png
```
### output seeking

When used as an output option (before an output url), decodes but discards input until the timestamps reach position.
- 由于input已经被解码了，因此每帧的timestamp可以获得，seek到指定位置前的frame。
- Here, the input will be decoded (and discarded) until it reaches the position given by `-ss`. This will be done **very slowly**, frame by frame.
- As of FFmpeg 2.1, the main advantage is that when applying filters to the output stream, the **timestamps aren't reset prior to filtering** (i.e. when [​burning subtitles into a video](https://trac.ffmpeg.org/wiki/HowToBurnSubtitlesIntoVideo), you don't need to modify the subtitle timestamps),

```
ffprobe -select_streams v -show_frames -show_entries frame=pict_type,pkt_pts_time src.mkv
```

```
[FRAME]
pkt_pts_time=0.613000
pict_type=I
[/FRAME]
[FRAME]
pkt_pts_time=0.630000
pict_type=B
[/FRAME]
...
[FRAME]
pkt_pts_time=1.130000
pict_type=B
[/FRAME]
[FRAME]
pkt_pts_time=1.147000
pict_type=I
[/FRAME]
```


### 一些选项

-copyts

Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value.
Note that, depending on the vsync option or on specific muxer processing (e.g. in case the format option avoid_negative_ts is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected.

-start_at_zero

When used with copyts, shift input timestamps so they start at zero.
This means that using e.g. `-ss 50` will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at.


-avoid_negative_ts integer (_output_)

Possible values:
‘make_non_negative’
Shift timestamps to make them non-negative. Also note that this affects only leading negative timestamps, and not non-monotonic negative timestamps.

‘make_zero’
Shift timestamps so that the first timestamp is 0.

‘auto (default)’
Enables shifting when required by the target format.

‘disabled’
Disables shifting of timestamp.

When shifting is enabled, all output timestamps are shifted by the same amount. Audio, video, and subtitles desynching and relative timestamp differences are preserved compared to how they would have been without shifting.

## 转码

### 音频

```bash
fyyuan@icarus4 ➜  Media ffmpeg -vn -i src.mkv -c:a aac -b:a 256k audio.mp3
Stream mapping:
  Stream #0:1 -> #0:0 (aac_latm (native) -> aac (native))
Press [q] to stop, [?] for help
[mp3 @ 0x564c9fc61340] Invalid audio stream. Exactly one MP3 audio stream is required.
Could not write header for output file #0 (incorrect codec parameters ?): Invalid argument
Error initializing output stream 0:0 --
[aac @ 0x564c9fc60900] Qavg: nan
Conversion failed!
```

### h264

[Encode/H.264 – FFmpeg](https://trac.ffmpeg.org/wiki/Encode/H.264)

两种模式
- CRF：不关心文件大小
- 2pass: 对文件大小有要求的场景，比如streaming

```
ffmpeg -i input -c:v libx264 -preset slow -crf 22 -c:a copy output.mkv
```

我使用这段参数转码h265的男子高中生S01E01，从514->320MB，结果质量很差
```
ffmpeg.exe -i video.mkv -map 0 -c:v libx264 -crf 18 out-h264-cpu.mkv
```

#### CRF
```
ffmpeg -i INPUT -c:v libx264 -crf 22 -preset slow -tune film -profile:v high10 -c:a aac -b:a 320k  OUTPUT


frame=31195 fps= 52 q=-1.0 Lsize= 1789175kB time=00:08:41.00 bitrate=28132.0kbits/s speed=0.863x
video:1768370kB audio:20388kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.023303%
[libx264 @ 0x5600dc3637c0] frame I:149   Avg QP:30.35  size:340646
[libx264 @ 0x5600dc3637c0] frame P:8748  Avg QP:33.31  size:125510
[libx264 @ 0x5600dc3637c0] frame B:22298 Avg QP:36.79  size: 29693
[libx264 @ 0x5600dc3637c0] consecutive B-frames:  1.9%  7.6%  2.5% 88.0%
[libx264 @ 0x5600dc3637c0] mb I  I16..4: 35.7% 56.8%  7.6%
[libx264 @ 0x5600dc3637c0] mb P  I16..4: 19.4% 13.1%  0.6%  P16..4: 37.2%  7.4%  3.3%  0.0%  0.0%    skip:18.9%
[libx264 @ 0x5600dc3637c0] mb B  I16..4:  1.0%  0.9%  0.0%  B16..8: 28.7%  2.2%  0.3%  direct: 2.0%  skip:64.8%  L0:39.9% L1:52.9% BI: 7.1%
[libx264 @ 0x5600dc3637c0] 8x8 transform intra:41.3% inter:87.3%
[libx264 @ 0x5600dc3637c0] direct mvs  spatial:99.8% temporal:0.2%
[libx264 @ 0x5600dc3637c0] coded y,uvDC,uvAC intra: 22.8% 49.0% 8.8% inter: 7.7% 12.4% 0.6%
[libx264 @ 0x5600dc3637c0] i16 v,h,dc,p: 20% 24%  8% 49%
[libx264 @ 0x5600dc3637c0] i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 12% 13% 13%  7% 11% 11% 13%  9% 11%
[libx264 @ 0x5600dc3637c0] i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 13% 15%  8%  7% 13% 11% 13%  8% 12%
[libx264 @ 0x5600dc3637c0] i8c dc,h,v,p: 45% 24% 15% 16%
[libx264 @ 0x5600dc3637c0] Weighted P-Frames: Y:1.8% UV:1.0%
[libx264 @ 0x5600dc3637c0] ref P L0: 74.3% 16.2%  5.7%  3.7%  0.1%  0.0%
[libx264 @ 0x5600dc3637c0] ref B L0: 90.6%  6.6%  2.0%  0.8%
[libx264 @ 0x5600dc3637c0] ref B L1: 98.3%  1.7%
[libx264 @ 0x5600dc3637c0] kb/s:27827.21
[aac @ 0x5600dc395700] Qavg: 174.559
```
### h265

[Encode/H.265 – FFmpeg](https://trac.ffmpeg.org/wiki/Encode/H.265)

- Choose a CRF. CRF affects the quality. The default is 28, and it should visually correspond to libx264 video at CRF 23, but result in about half the file size. CRF works just like in x264, so choose the highest value that provides an acceptable quality.

- Choose a preset. The default is `medium`. The preset determines compression efficiency and therefore affects encoding speed. Valid presets are `ultrafast`, `superfast`, `veryfast`, `faster`, `fast`, `medium`, `slow`, `slower`, `veryslow`, and `placebo`. Use the slowest preset you have patience for. Ignore `placebo` as it provides insignificant returns for a significant increase in encoding time.

- Choose a tune (optional). By default, this is disabled, and it is generally not required to set a tune option. x265 supports the following `-tune` options: `psnr`, `ssim`, `grain`, `zerolatency`, `fastdecode`. They are explained in the [H.264 guide](https://trac.ffmpeg.org/wiki/Encode/H.264#crf).

#### CRF

直接转码，仍使用了原本的59.94fps
```
ffmpeg -i INPUT -c:v libx265 -crf 26 -preset slow -c:a aac -b:a 320k OUTPUT

frame=31195 fps= 12 q=35.8 Lsize=  709168kB time=00:08:41.00 bitrate=11150.6kbits/s speed=0.195x
video:688379kB audio:20388kB subtitle:0kB other streams:0kB global headers:2kB muxing overhead: 0.056575%
x265 [info]: frame I:    132, Avg QP:27.54  kb/s: 60301.51
x265 [info]: frame P:   7805, Avg QP:29.13  kb/s: 28855.09
x265 [info]: frame B:  23258, Avg QP:34.69  kb/s: 4505.13
x265 [info]: Weighted P-Frames: Y:1.7% UV:1.4%
x265 [info]: consecutive B-frames: 1.0% 2.5% 2.3% 91.0% 3.3%

encoded 31195 frames in 2677.46s (11.65 fps), 10833.60 kb/s, Avg QP:33.27
[aac @ 0x55d67964f4c0] Qavg: 174.559
```

设置帧率60fps
```
ffmpeg -i INPUT -c:v libx265 -crf 26 -preset slow -r 60 -c:a aac -b:a 320k OUTPUT


frame=31195 fps=8.3 q=36.0 Lsize=  708843kB time=00:08:41.00 bitrate=11145.6kbits/s speed=0.139x
video:688054kB audio:20388kB subtitle:0kB other streams:0kB global headers:2kB muxing overhead: 0.056600%
x265 [info]: frame I:    132, Avg QP:27.54  kb/s: 60361.57
x265 [info]: frame P:   7805, Avg QP:29.14  kb/s: 28870.71
x265 [info]: frame B:  23258, Avg QP:34.70  kb/s: 4507.21
x265 [info]: Weighted P-Frames: Y:1.7% UV:1.4%
x265 [info]: consecutive B-frames: 1.0% 2.5% 2.3% 91.0% 3.3%

encoded 31195 frames in 3751.69s (8.31 fps), 10839.31 kb/s, Avg QP:33.27
[aac @ 0x56079a852080] Qavg: 174.559

```

src(59.94)   1080p(30)   2160p(59.94)
41.149  40.566  40.539
41.002  41.045  41.045

60         59.94
41.171   41.175
41.023   41.023

### av1

[Encode/AV1 – FFmpeg](https://trac.ffmpeg.org/wiki/Encode/AV1)

Constant Quality：

libaom-av1 has a constant quality (CQ) mode (like CRF in x264 and x265) which will ensure that *every frame gets the number of bits it deserves to achieve a certain (perceptual) quality level*, rather than encoding each frame to meet a bit rate target. This results in better overall quality. **If you do not need to achieve a fixed target file size, this should be your method of choice.**

```
ffmpeg -i input.mp4 -c:v libaom-av1 -crf 30 -b:v 0 av1_test.mkv
```

慢到不可用！！！


## 调节帧数

[ffmpeg - Best way to convert a 59.94fps video to 29.97? - Stack Overflow](https://stackoverflow.com/questions/33749109/best-way-to-convert-a-59-94fps-video-to-29-97)

[[FFmpeg-user] framerate conversion with sync audio (narkive.com)](https://ffmpeg-user.ffmpeg.narkive.com/VAyCRakI/framerate-conversion-with-sync-audio)
这位老哥的需求时将24fps的视频转成25fps，要求单纯只是加速，不改变frame内容。由于改变了video的速率，因此也要同时改变audio的速率，最后的结果命令
- 有老哥说-r不是很可靠，建议使用`-vf setpts=PTS*0.8`
- 还有老哥提议测试以下`asetpts` filter是否可以
```
ffmpeg -r 25 -i input_24fps.mov -af asetrate=50000,aresample=48000 -c:v  
prores -profile:v 3 -c:a pcm_s24le output_25fps_resampledaudio.mov
```

[What is video timescale, timebase, or timestamp in ffmpeg? - Stack Overflow](https://stackoverflow.com/questions/43333542/what-is-video-timescale-timebase-or-timestamp-in-ffmpeg)
- 每frame包含timestamp信息。**P**resentation **T**ime**S**tamps，表示其应该显示的时间？
- For the sake of precise resolution of these time values, a timebase is used。比如1/75为单位
- timescale即timebase的倒数，FFmpeg shows the timescale as the `tbn` value in the readout of a stream.

## GPU硬件加速

测试视频：[Big Buck Bunny » Download (blender.org)](https://peach.blender.org/download/)


**强烈推荐**：[Hardware/VAAPI – FFmpeg](https://trac.ffmpeg.org/wiki/Hardware/VAAPI)

https://wiki.libav.org/Hardware/vaapi

https://www.hardening-consulting.com/en/posts/20170625-using-vaapi-with-ffmpeg.html

查看支持的h264编解码
```
ffmpeg -codecs|grep 264

DEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (decoders: h264 h264_v4l2m2m h264_qsv h264_cuvid ) (encoders: libx264 libx264rgb h264_nvenc h264_omx h264_qsv h264_v4l2m2m h264_vaapi )
```

下载h265测试视频
[MP4 ( H.265 ) | Test Videos (test-videos.co.uk)](https://test-videos.co.uk/bigbuckbunny/mp4-h265)

### vaapi测试

使用vaapi需要以下库
```
apt install va-driver-all mesa-va-drivers
```

基本测试，测试权限之类的
```
ffmpeg -init_hw_device vaapi=va:/dev/dri/renderD128
```

调用vaapi加速编码
```
ffmpeg -y -vaapi_device /dev/dri/renderD128 -i Big_Buck_Bunny_1080_10s_30MB.mp4 -vf 'format=nv12,hwupload' -c:v h264_vaapi output.mp4

ffmpeg -y -i Big_Buck_Bunny_1080_10s_30MB.mp4 -c:v libx264 output.mp4
```
如果设备支持硬件解码
-  hwaccel vaapi指定使用硬件解码
```
ffmpeg -hwaccel vaapi -hwaccel_output_format vaapi -hwaccel_device /dev/dri/renderD128 -i input.mp4 -c:v h264_vaapi output.mp4
```


- n5105 UHD核显，转码big bunny 1080p 30fps, 25Mb/s码率大概50fps
- 使用cpu转则只有13fps

vainfo
```
error: can't connect to X server!
libva info: VA-API version 1.7.0
libva info: Trying to open /usr/lib/x86_64-linux-gnu/dri/radeonsi_drv_video.so
libva info: Found init function __vaDriverInit_1_7
libva info: va_openDriver() returns 0
vainfo: VA-API version: 1.7 (libva 2.6.0)
vainfo: Driver version: Mesa Gallium driver 21.2.6 for AMD Radeon (TM) R7 M340 (ICELAND, DRM 3.42.0, 5.15.0-86-generic, LLVM 12.0.0)
vainfo: Supported profile and entrypoints
      VAProfileMPEG2Simple            : VAEntrypointVLD
      VAProfileMPEG2Main              : VAEntrypointVLD
      VAProfileNone                   : VAEntrypointVideoProc
```

n5105
```
root@n5105-pve ➜  test vainfo
error: can't connect to X server!
libva info: VA-API version 1.17.0
libva info: Trying to open /usr/lib/x86_64-linux-gnu/dri/iHD_drv_video.so
libva info: Found init function __vaDriverInit_1_17
libva info: va_openDriver() returns 0
vainfo: VA-API version: 1.17 (libva 2.12.0)
vainfo: Driver version: Intel iHD driver for Intel(R) Gen Graphics - 23.1.1 ()
vainfo: Supported profile and entrypoints
      VAProfileNone                   : VAEntrypointVideoProc
      VAProfileNone                   : VAEntrypointStats
      VAProfileMPEG2Simple            : VAEntrypointVLD
      VAProfileMPEG2Main              : VAEntrypointVLD
      VAProfileH264Main               : VAEntrypointVLD
      VAProfileH264Main               : VAEntrypointEncSliceLP
      VAProfileH264High               : VAEntrypointVLD
      VAProfileH264High               : VAEntrypointEncSliceLP
      VAProfileJPEGBaseline           : VAEntrypointVLD
      VAProfileJPEGBaseline           : VAEntrypointEncPicture
      VAProfileH264ConstrainedBaseline: VAEntrypointVLD
      VAProfileH264ConstrainedBaseline: VAEntrypointEncSliceLP
      VAProfileVP8Version0_3          : VAEntrypointVLD
      VAProfileHEVCMain               : VAEntrypointVLD
      VAProfileHEVCMain               : VAEntrypointEncSliceLP
      VAProfileHEVCMain10             : VAEntrypointVLD
      VAProfileHEVCMain10             : VAEntrypointEncSliceLP
      VAProfileVP9Profile0            : VAEntrypointVLD
      VAProfileVP9Profile0            : VAEntrypointEncSliceLP
      VAProfileVP9Profile1            : VAEntrypointVLD
      VAProfileVP9Profile1            : VAEntrypointEncSliceLP
      VAProfileVP9Profile2            : VAEntrypointVLD
      VAProfileVP9Profile2            : VAEntrypointEncSliceLP
      VAProfileVP9Profile3            : VAEntrypointVLD
      VAProfileVP9Profile3            : VAEntrypointEncSliceLP
      VAProfileHEVCMain422_10         : VAEntrypointVLD
      VAProfileHEVCMain444            : VAEntrypointVLD
      VAProfileHEVCMain444            : VAEntrypointEncSliceLP
      VAProfileHEVCMain444_10         : VAEntrypointVLD
      VAProfileHEVCMain444_10         : VAEntrypointEncSliceLP
```


## 时间戳相关

DTS解码时间戳
```
[matroska @ 0x55a111e20440] Non-monotonous DTS in output stream 0:1; previous: 565, current: 564; changing to 565. This may result in incorrect timestamps in the output file.
```

### 选项

-copyts

Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value.

Note that, depending on the vsync option or on specific muxer processing (e.g. in case the format option avoid_negative_ts is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected.

-start_at_zero

When used with copyts, shift input timestamps so they start at zero.

This means that using e.g. `-ss 50` will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at.

-copytb mode

Specify how to set the encoder timebase when stream copying. mode is an integer numeric value, and can assume one of the following values:

1

Use the demuxer timebase.

The time base is copied to the output encoder from the corresponding input demuxer. This is sometimes required to avoid non monotonically increasing timestamps when copying video streams with variable frame rate.

0

Use the decoder timebase.

The time base is copied to the output encoder from the corresponding input decoder.

-1

Try to make the choice automatically, in order to generate a sane output.

Default value is -1.
### ffmpeg输出时间戳默认会置为0

[ffmpeg demux into audio and video resets PTS - Stack Overflow](https://stackoverflow.com/questions/51585661/ffmpeg-demux-into-audio-and-video-resets-pts)
- ffmpeg分离video时会reset timestamp？

构造一个start为1h的视频
```
ffmpeg -i bbb_sunflower_1080p_30fps_normal.mp4 -c copy -output_ts_offset 3600 test.mkv
```

查看确实start_time = 3600
- 使用mpv播放进度条仍为0
- 使用windows自带的视频播放器，进度条确实从1h开始
- 文件管理器显示的视频时常也确实增加了1h
```
Input #0, matroska,webm, from 'test.mkv':
  Metadata:
    title           : Big Buck Bunny, Sunflower version
    GENRE           : Animation
    MAJOR_BRAND     : isom
    MINOR_VERSION   : 1
    COMPATIBLE_BRANDS: isomavc1
    COMPOSER        : Sacha Goedegebure
    ARTIST          : Blender Foundation 2008, Janus Bager Kristensen 2013
    COMMENT         : Creative Commons Attribution 3.0 - http://bbb3d.renderfarming.net
    ENCODER         : Lavf58.76.100
  Duration: 01:10:34.60, start: 3600.000000, bitrate: 497 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], 30 fps, 30 tbr, 1k tbn, 60 tbc (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Video Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 01:10:34.600000000
  Stream #0:1: Audio: ac3, 48000 Hz, 5.1(side), fltp, 320 kb/s (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Audio Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 01:10:34.144000000
start_pts=3600067
start_time=3600.067000
start_pts=3600000
start_time=3600.000000
```

ffmpeg复制一下
```
ffmpeg -i test.mkv -c copy test_copy.mkv
```

确实start被置为0了，即
```
Input #0, matroska,webm, from 'test_copy.mkv':
  Metadata:
    title           : Big Buck Bunny, Sunflower version
    COMMENT         : Creative Commons Attribution 3.0 - http://bbb3d.renderfarming.net
    GENRE           : Animation
    MAJOR_BRAND     : isom
    MINOR_VERSION   : 1
    COMPATIBLE_BRANDS: isomavc1
    COMPOSER        : Sacha Goedegebure
    ARTIST          : Blender Foundation 2008, Janus Bager Kristensen 2013
    ENCODER         : Lavf58.76.100
  Duration: 00:10:34.60, start: 0.000000, bitrate: 3321 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], 30 fps, 30 tbr, 1k tbn, 60 tbc (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Video Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:10:34.600000000
  Stream #0:1: Audio: ac3, 48000 Hz, 5.1(side), fltp, 320 kb/s (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Audio Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:10:34.144000000
start_pts=67
start_time=0.067000
start_pts=0
start_time=0.000000
```

### ffmpeg合并视频和音频，默认居然会有问题

将视频分解为视频和音频
```
ffmpeg -i bbb_sunflower_1080p_30fps_normal.mkv -vn -c copy a.m4a -an -c copy a.mkv
```

对音频进行截切和偏移（剪掉前1.7s，同时往右偏移1.7s，因此相对于base还是同步的）
```
ffmpeg -ss 1.7 -itsoffset 1.7 -i a.m4a -c copy b.m4a
```

```
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'b.m4a':
  Metadata:
    major_brand     : M4A
    minor_version   : 512
    compatible_brands: M4A isomiso2
    title           : Big Buck Bunny, Sunflower version
    artist          : Blender Foundation 2008, Janus Bager Kristensen 2013
    composer        : Sacha Goedegebure
    encoder         : Lavf58.76.100
    comment         : Creative Commons Attribution 3.0 - http://bbb3d.renderfarming.net
    genre           : Animation
  Duration: 00:10:34.14, start: 1.696000, bitrate: 319 kb/s
  Stream #0:0(und): Audio: ac3 (ac-3 / 0x332D6361), 48000 Hz, 5.1(side), fltp, 320 kb/s (default)
    Metadata:
      handler_name    : GPAC ISO Audio Handler
      vendor_id       : [0][0][0][0]
    Side data:
      audio service type: main
start_pts=81408
start_time=1.696000
```

将原本视频和音频合并
`ffmpeg -i a.mkv -i b.m4a -c copy merge2.mkv`
- ffmpeg直接忽视了input的时间戳，将其认为是从0开始的，然后合并。因此导致声音相比于正确情况提前了。
```
Input #0, matroska,webm, from 'merge.mkv':
  Metadata:
    title           : Big Buck Bunny, Sunflower version
    ARTIST          : Blender Foundation 2008, Janus Bager Kristensen 2013
    COMMENT         : Creative Commons Attribution 3.0 - http://bbb3d.renderfarming.net
    GENRE           : Animation
    MAJOR_BRAND     : isom
    MINOR_VERSION   : 1
    COMPATIBLE_BRANDS: isomavc1
    COMPOSER        : Sacha Goedegebure
    ENCODER         : Lavf58.76.100
  Duration: 00:10:34.53, start: 0.000000, bitrate: 3321 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], 30 fps, 30 tbr, 1k tbn, 60 tbc (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Video Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:10:34.533000000
  Stream #0:1: Audio: ac3, 48000 Hz, 5.1(side), fltp, 320 kb/s (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Audio Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:10:32.448000000
start_pts=0
start_time=0.000000
start_pts=0
start_time=0.000000
```

正确合并
`ffmpeg -i a.mkv -i b.m4a -copyts -c copy merge2.mkv`
```
Input #0, matroska,webm, from 'merge2.mkv':
  Metadata:
    title           : Big Buck Bunny, Sunflower version
    ARTIST          : Blender Foundation 2008, Janus Bager Kristensen 2013
    COMMENT         : Creative Commons Attribution 3.0 - http://bbb3d.renderfarming.net
    GENRE           : Animation
    MAJOR_BRAND     : isom
    MINOR_VERSION   : 1
    COMPATIBLE_BRANDS: isomavc1
    COMPOSER        : Sacha Goedegebure
    ENCODER         : Lavf58.76.100
  Duration: 00:10:34.60, start: 0.067000, bitrate: 3320 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], 30 fps, 30 tbr, 1k tbn, 60 tbc (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Video Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:10:34.600000000
  Stream #0:1: Audio: ac3, 48000 Hz, 5.1(side), fltp, 320 kb/s (default)
    Metadata:
      HANDLER_NAME    : GPAC ISO Audio Handler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:10:34.144000000
start_pts=67
start_time=0.067000
start_pts=1696
start_time=1.696000
```

### delay某个流

强行将音频delay 0.613s，可以导致不同步
```
(base) fyyuan@icarus4 ➜  reset_pts ffmpeg -i ../src.mkv -itsoffset 0.613 -i ../src.mkv -map 0:0 -map 1:1 -c copy -shortest output_video_adjusted.mkv

Input #0, matroska,webm, from 'output_video_adjusted.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.15, start: 0.613000, bitrate: 24908 kb/s
  Stream #0:0: Video: hevc (Main 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)
    Metadata:
      DURATION        : 00:08:41.149000000
  Stream #0:1: Audio: aac_latm (LC) ([2][22][0][0] / 0x1602), 48000 Hz, 5.1, fltp (default)
    Metadata:
      DURATION        : 00:08:41.018000000
start_pts=613
start_time=0.613000
start_pts=613
start_time=0.613000
```

## B站问题

### 为什么seek 0.638s，结果导致video起始变成了4.1s

现象就是视频少了4s，mpv播放时起始直接变成了4s
```
Input #0, matroska,webm, from 'src.hevc.aac.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.18, start: 0.000000, bitrate: 11146 kb/s
  Stream #0:0: Video: hevc (Main 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10, progressive), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)
    Metadata:
      ENCODER         : Lavc58.134.100 libx265
      DURATION        : 00:08:41.175000000
  Stream #0:1: Audio: aac (LC), 48000 Hz, 5.1, fltp (default)
    Metadata:
      ENCODER         : Lavc58.134.100 aac
      DURATION        : 00:08:41.023000000
start_pts=638
start_time=0.638000
start_pts=0
start_time=0.000000
```

```
ffmpeg -i src.hevc.aac.mkv -ss 0.638 -c copy cut.hevc.aac.ss638.mkv
```

```
Input #0, matroska,webm, from 'cut.hevc.aac.ss638.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:40.54, start: 0.002000, bitrate: 10998 kb/s
  Stream #0:0: Video: hevc (Main 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10, progressive), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)
    Metadata:
      ENCODER         : Lavc58.134.100 libx265
      DURATION        : 00:08:40.536000000
  Stream #0:1: Audio: aac (LC), 48000 Hz, 5.1, fltp (default)
    Metadata:
      ENCODER         : Lavc58.134.100 aac
      DURATION        : 00:08:40.385000000
start_pts=4171
start_time=4.171000
start_pts=2
start_time=0.002000
```

怀疑是seek，seek到下一个关键帧了，导致丢失了关键帧前的所有数据（虽然chatgpt告诉我seek是seek到之前的关键帧）

### 感觉问题在于为什么自己的视频video和audio duration相差没那么大，而B站转码后，就相差0.5s了

分p版本
源文件
```
Input #0, matroska,webm, from 'p09.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.15, start: 0.000000, bitrate: 24909 kb/s
  Stream #0:0: Video: hevc (Main 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)
    Metadata:
      DURATION        : 00:08:41.149000000
  Stream #0:1: Audio: aac_latm (LC) ([2][22][0][0] / 0x1602), 48000 Hz, 5.1, fltp (default)
    Metadata:
      DURATION        : 00:08:41.002000000
start_pts=613
start_time=0.613000
start_pts=0
start_time=0.000000
```

b站下载的
```
➜  yt-dlp ./yt-dlp https://www.bilibili.com/video/BV1dG411z7sc -F -I 9
[BiliBili] Extracting URL: https://www.bilibili.com/video/BV1dG411z7sc
[BiliBili] 1dG411z7sc: Downloading webpage
[BiliBili] BV1dG411z7sc: Extracting videos in anthology
[BiliBili] Downloading playlist BV1dG411z7sc - add --no-playlist to download just the video BV1dG411z7sc
[download] Downloading playlist: 【第73回NHK紅白歌合戦 BS4K】节选
[BiliBili] Playlist 【第73回NHK紅白歌合戦 BS4K】节选: Downloading 1 items
[download] Downloading item 1 of 1
[BiliBili] Extracting URL: https://www.bilibili.com/video/BV1dG411z7sc?p=9
[BiliBili] 1dG411z7sc: Downloading webpage
[BiliBili] BV1dG411z7sc: Extracting videos in anthology
[BiliBili] 410742370: Extracting chapters
[info] Available formats for BV1dG411z7sc_p9:
ID    EXT RESOLUTION FPS │   FILESIZE    TBR PROTO │ VCODEC         VBR ACODEC      ABR
───────────────────────────────────────────────────────────────────────────────────────
30216 m4a audio only     │ ≈  2.51MiB    39k https │ audio only         mp4a.40.5   39k
30232 m4a audio only     │ ≈  5.88MiB    92k https │ audio only         mp4a.40.2   92k
30280 m4a audio only     │ ≈  9.87MiB   155k https │ audio only         mp4a.40.2  155k
30016 mp4 640x360     30 │ ≈ 23.35MiB   367k https │ avc1.64001E   367k video only
30032 mp4 852x480     30 │ ≈ 52.44MiB   824k https │ avc1.64001F   824k video only
30064 mp4 1280x720    30 │ ≈116.21MiB  1827k https │ avc1.640028  1827k video only
30080 mp4 1920x1080   30 │ ≈173.36MiB  2725k https │ avc1.640032  2725k video only
30116 mp4 1920x1080   59 │ ≈346.03MiB  5439k https │ avc1.640032  5439k video only
30120 mp4 3840x2160   59 │ ≈  1.16GiB 18644k https │ avc1.640034 18644k video only
[download] Finished downloading playlist: 【第73回NHK紅白歌合戦 BS4K】节选
```
(这里是yt-dlp的bug，需要加copyts，否则合并时会丢弃input timestamp。不过我试了手动merge，貌似仍然不同步，这次变成音频要快一点)
```
Input #0, matroska,webm, from 'bili-p09.mkv':
  Metadata:
    DESCRIPTION     : Packed by Bilibili XCoder v2.0.2
    MAJOR_BRAND     : iso5
    MINOR_VERSION   : 1
    COMPATIBLE_BRANDS: avc1iso5dsmsmsixdash
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.05, start: 0.000000, bitrate: 18779 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(tv, bt709, progressive), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 119.88 tbc (default)
    Metadata:
      HANDLER_NAME    : VideoHandler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:08:40.539000000
  Stream #0:1: Audio: aac (LC), 48000 Hz, stereo, fltp (default)
    Metadata:
      HANDLER_NAME    : SoundHandler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:08:41.045000000
start_pts=0
start_time=0.000000
start_pts=0
start_time=0.000000
```
手动合并的（这里的1.226不就是0.613的两倍吗）（果然，将音频delay +600ms后，就很同步了）
```
Input #0, matroska,webm, from 'p9.mkv':
  Metadata:
    DESCRIPTION     : Packed by Bilibili XCoder v2.0.2
    MAJOR_BRAND     : iso5
    MINOR_VERSION   : 1
    COMPATIBLE_BRANDS: avc1iso5dsmsmsixdash
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.77, start: 0.000000, bitrate: 18753 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(tv, bt709, progressive), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 119.88 tbc (default)
    Metadata:
      HANDLER_NAME    : VideoHandler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:08:41.765000000
  Stream #0:1: Audio: aac (LC), 48000 Hz, stereo, fltp (default)
    Metadata:
      HANDLER_NAME    : SoundHandler
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:08:41.045000000
start_pts=1226
start_time=1.226000
start_pts=0
start_time=0.000000
```

原因在于这里的duration是包含start_pts的，因此源视频的video就比audio少约0.5s

使用setpts（后面发现该命令是filter因此需要转码，速度很慢，实际上对可以input video单独设置input pts offset，后面会用到该命令进行修复），可以复现duration差值变大
```
 ffmpeg -i src.mkv -filter_complex "[0:v]setpts=PTS-STARTPTS[v];[0:a]asetpts=PTS-STARTPTS[a]" -map "[v]" -map "[a]" setpts.mkv
```

```
Input #0, matroska,webm, from 'setpts.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.01, start: 0.000000, bitrate: 20558 kb/s
  Stream #0:0: Video: h264 (High 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10, progressive), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 119.88 tbc (default)
    Metadata:
      ENCODER         : Lavc58.134.100 libx264
      DURATION        : 00:08:40.540000000
  Stream #0:1: Audio: vorbis, 48000 Hz, 5.1, fltp (default)
    Metadata:
      ENCODER         : Lavc58.134.100 libvorbis
      DURATION        : 00:08:41.006000000
start_pts=0
start_time=0.000000
start_pts=0
start_time=0.000000
```
### 猜想问题原因

可以看到我上传到B站的文件视频流的起始帧的pts为0.613s，差不多正是B站音画不同步的时间
```
Input #0, matroska,webm, from 'src.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.15, start: 0.000000, bitrate: 24909 kb/s
  Stream #0:0: Video: hevc (Main 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)
    Metadata:
      DURATION        : 00:08:41.149000000
  Stream #0:1: Audio: aac_latm (LC) ([2][22][0][0] / 0x1602), 48000 Hz, 5.1, fltp (default)
    Metadata:
      DURATION        : 00:08:41.002000000
start_pts=613
start_time=0.613000
start_pts=0
start_time=0.000000
```
并且经过很多次转码实验，发现转码并不能重置掉这个start_pts，而是基本完全保留
```
src.hevc.aac.60fps.mkv  start_pts=638
src.hevc.aac.mkv  start_pts=638
src.avc.mkv start_pts=638
```

而start_pts的含义便是视频的第一帧应该显示出来的时间。
如果我把这个pts重置为0，视频就会比音频提前（假设原本的pts，音画是同步的话）

而yt-dlp下载B站视频时，视频和音频是分开下载，最后再合并成一个视频的。
我观察了好几个yt-dlp下载的视频，发现start_pts都变成了0。所以猜测：
- ~~B站转码的时候将pts重置为了0（每个frame 做如下filter：`[0:v]setpts=PTS-STARTPTS[v]`）~~
- ~~后面发现yt-dlp合并时丢弃了原本的ts，将两个流当作start_pts=0进行合并的。B站的视频和音频文件是有offset~~
- ~~但是即使手动-copyts合并，仍然不同步，并且这次变成音频提前了。~~
UDPATE: 是yt-dlp会清除timestamps。不过这里的问题在于B站好像也忽略了时间戳，导致不同步

至于为什么一开始使用-ss剪辑出8分钟的片段时，pts为613而不是干脆置为0。**怀疑流复制情况，只能seek到pos之后的一个关键帧**（而不是chatgpt告诉我的seek到之前的关键帧）
### 其它

#### 发现原始视频有两个audio

```
Input #0, mpegts, from '2022-12-31 第73回NHK 紅白歌合戦 NHK BS4K.m2ts':
  Duration: 04:25:01.42, start: 61.462067, bitrate: 26406 kb/s
  Program 101
  Stream #0:0[0x1011]: Video: hevc (Main 10) (HESE / 0x45534548), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 90k tbn, 59.94 tbc
  Stream #0:1[0x1100]: Audio: aac_latm (LC) ([17][0][0][0] / 0x0011), 48000 Hz, stereo, fltp
  Stream #0:2[0x1c00]: Data: bin_data ([6][0][0][0] / 0x0006)
  Stream #0:3[0x1c01]: Data: bin_data ([6][0][0][0] / 0x0006)
  Stream #0:4[0x1101]: Audio: aac_latm (LC) ([17][0][0][0] / 0x0011), 48000 Hz, stereo, fltp
Unsupported codec with id 100359 for input stream 2
Unsupported codec with id 100359 for input stream 3
start_pts=5577842
start_time=61.976022
start_pts=5531586
start_time=61.462067
start_pts=5531586
start_time=61.462067
start_pts=5531586
start_time=61.462067
start_pts=5589186
start_time=62.102067
```


#### youtube没问题

yt-dlp合并视频和音频时，究竟是如何对准ts的？
```
Input #0, mpegts, from 'youtube.f312.mp4':
  Duration: 00:08:41.15, start: 0.016678, bitrate: 5441 kb/s
  Program 1
  Stream #0:0[0x100]: Video: h264 (High) ([27][0][0][0] / 0x001B), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 90k tbn, 119.88 tbc
start_pts=1501
start_time=0.016678

Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'youtube.f380.m4a':
  Metadata:
    major_brand     : dash
    minor_version   : 0
    compatible_brands: iso6mp41
    creation_time   : 2024-01-02T23:44:20.000000Z
  Duration: 00:08:41.15, start: 0.000000, bitrate: 384 kb/s
  Stream #0:0(und): Audio: ac3 (ac-3 / 0x332D6361), 48000 Hz, 5.1(side), fltp, 384 kb/s (default)
    Metadata:
      creation_time   : 2024-01-02T23:44:20.000000Z
      handler_name    : ISO Media file produced by Google Inc.
      vendor_id       : [0][0][0][0]
    Side data:
      audio service type: main
start_pts=0
start_time=0.000000

Input #0, matroska,webm, from 'youtube.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.15, start: 0.000000, bitrate: 5661 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 119.88 tbc (default)
    Metadata:
      DURATION        : 00:08:41.154000000
  Stream #0:1: Audio: ac3, 48000 Hz, 5.1(side), fltp, 384 kb/s (default)
    Metadata:
      HANDLER_NAME    : ISO Media file produced by Google Inc.
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:08:41.152000000
start_pts=0
start_time=0.000000
start_pts=0
start_time=0.000000
```

手动merge + -copyts
```
Input #0, matroska,webm, from 'youtube-hand-merge2.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:41.17, start: 0.000000, bitrate: 5661 kb/s
  Stream #0:0: Video: h264 (High), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 119.88 tbc (default)
    Metadata:
      DURATION        : 00:08:41.171000000
  Stream #0:1: Audio: ac3, 48000 Hz, 5.1(side), fltp, 384 kb/s (default)
    Metadata:
      HANDLER_NAME    : ISO Media file produced by Google Inc.
      VENDOR_ID       : [0][0][0][0]
      DURATION        : 00:08:41.152000000
start_pts=17
start_time=0.017000
start_pts=0
start_time=0.000000
```

### 设置输入和输出pts

尝试cut + reset offset
- 重点在于-itsoffset是对输入的文件的所有流加上一个偏移
- 而output则是对输出的再加上个偏移
```
ffmpeg -vn -ss 0.613 -itsoffset 0.613 -i ../src.mkv -an -i ../src.mkv -c copy -map 0:a -map 1:v -output_ts_offset -0.613 output_combined.mkv


Input #0, matroska,webm, from 'output_combined.mkv':
  Metadata:
    ENCODER         : Lavf58.76.100
  Duration: 00:08:40.59, start: 0.000000, bitrate: 24935 kb/s
  Stream #0:0: Audio: aac_latm (LC) ([2][22][0][0] / 0x1602), 48000 Hz, 5.1, fltp (default)
    Metadata:
      DURATION        : 00:08:40.438000000
  Stream #0:1: Video: hevc (Main 10), yuv420p10le(tv, bt2020nc/bt2020/bt2020-10), 3840x2160 [SAR 1:1 DAR 16:9], 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)
    Metadata:
      DURATION        : 00:08:40.585000000
start_pts=55
start_time=0.055000
start_pts=0
start_time=0.000000
```

文件duration的不可靠，是包含了start_pts的
- **这解释了为什么从B站下载的文件，start_pts变0后，为什么duration相差很大**
- 相当于stream和文件duration，duration都是计算最长的？
